## Наследование и Полиморфизм в Python

Мы уже узнали о ключевых принципах ООП и познакомились с тем, как создавать классы и управлять приватными и публичными свойствами и методами. В этом уроке мы углубимся в две важные концепции объектно-ориентированного программирования — **наследование** и **полиморфизм**.

### 1. Наследование

**Наследование** позволяет создавать новые классы на основе существующих. Это значит, что новый класс (наследник) получает все свойства и методы родительского класса, но также может добавлять собственные или изменять существующие.

#### Пример наследования:

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def make_sound(self):
        return f"{self.name} издаёт звук"

# Наследуемся от класса Animal
class Dog(Animal):
    def make_sound(self):
        return f"{self.name} гавкает"

# Наследуемся от класса Animal
class Cat(Animal):
    def make_sound(self):
        return f"{self.name} мяукает"
```

В этом примере:
- Класс `Animal` является родительским, он определяет базовые свойства и методы.
- Классы `Dog` и `Cat` наследуют свойства и методы класса `Animal`, но переопределяют метод `make_sound`, чтобы отразить уникальные звуки.

#### Пример использования:

```python
dog = Dog("Бобик")
cat = Cat("Мурка")

print(dog.make_sound())  # Выведет: Бобик гавкает
print(cat.make_sound())  # Выведет: Мурка мяукает
```

В этом случае классы `Dog` и `Cat` используют общий метод `make_sound`, но результат разный для каждого класса благодаря переопределению метода в классах-наследниках.

### 2. Полиморфизм

**Полиморфизм** позволяет нам использовать одно и то же имя метода для объектов разных классов, при этом каждый класс может иметь свою реализацию этого метода. Благодаря полиморфизму объекты разных классов могут быть обработаны одинаковым образом, даже если они реализуют свои уникальные поведения.

#### Пример полиморфизма:

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def make_sound(self):
        return f"{self.name} издаёт звук"

class Dog(Animal):
    def make_sound(self):
        return f"{self.name} гавкает"

class Cat(Animal):
    def make_sound(self):
        return f"{self.name} мяукает"

class Cow(Animal):
    def make_sound(self):
        return f"{self.name} мычит"

# Функция, которая демонстрирует полиморфизм
def animal_sound(animal):
    print(animal.make_sound())

# Мы можем передать объект любого подкласса Animal
animals = [Dog("Бобик"), Cat("Мурка"), Cow("Бурёнка")]

for animal in animals:
    animal_sound(animal)
```

В этом примере функция `animal_sound` может работать с любым объектом, который является экземпляром класса `Animal` или его наследниками. Несмотря на то, что у каждого животного своя реализация метода `make_sound`, функция одинаково обращается со всеми объектами.

### 3. Наследование и Полиморфизм в практике: расширение игры "Змейка"

Теперь рассмотрим пример с наследованием и полиморфизмом в контексте нашей игры "Змейка". Представим, что в игре теперь может быть несколько видов змей: обычная змея и змея с ускорением. Мы создадим базовый класс `Snake`, а затем создадим класс-наследник `FastSnake`, который имеет более высокую скорость.

#### Базовый класс `Snake`:

```python
class Snake:
    def __init__(self, name, speed=5):
        self.name = name
        self.speed = speed
    
    def move(self):
        print(f"{self.name} движется со скоростью {self.speed}.")
```

#### Класс-наследник `FastSnake`:

```python
class FastSnake(Snake):
    def __init__(self, name, speed=5, boost=2):
        super().__init__(name, speed)
        self.boost = boost
    
    def move(self):
        # Используем полиморфизм для изменения поведения метода move
        boosted_speed = self.speed + self.boost
        print(f"{self.name} движется с ускоренной скоростью {boosted_speed}.")
```

#### Пример использования классов:

```python
normal_snake = Snake("Обычная змея")
fast_snake = FastSnake("Быстрая змея")

normal_snake.move()  # Обычная змея движется со скоростью 5.
fast_snake.move()    # Быстрая змея движется с ускоренной скоростью 7.
```

Здесь класс `FastSnake` наследует от класса `Snake`, но изменяет метод `move`, чтобы змея двигалась быстрее благодаря полиморфизму.

### Заключение

В этом уроке мы рассмотрели наследование и полиморфизм — два важных аспекта ООП, которые позволяют строить гибкие, расширяемые и поддерживаемые программы. Наследование позволяет создать классы, основанные на существующих, а полиморфизм обеспечивает гибкость в работе с объектами разных классов через общие интерфейсы.

Этот урок завершает второй модуль курса **Python проще простого**, посвящённый объектно-ориентированному программированию и базовым принципам данного языка. В следующем модуле мы совместим знания, полученные при изучении первого модуля со вторым и научимся решать математические задачи на Python.
